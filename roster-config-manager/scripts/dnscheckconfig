#!/usr/bin/env python

# Copyright (c) 2009, Purdue University
# All rights reserved.
# 
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
# 
# Redistributions of source code must retain the above copyright notice, this
# list of conditions and the following disclaimer.
#
# Redistributions in binary form must reproduce the above copyright notice, this
# list of conditions and the following disclaimer in the documentation and/or
# other materials provided with the distribution.
# 
# Neither the name of the Purdue University nor the names of its contributors
# may be used to endorse or promote products derived from this software without
# specific prior written permission.
# 
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 'AS IS'
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
# DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
# FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
# DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
# SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
# CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
# OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
# OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

"""Config check tool for Roster"""


__copyright__ = 'Copyright (C) 2009, Purdue University'
__license__ = 'BSD'
__version__ = '#TRUNK#'


import sys
import os
import tarfile
import shutil
import ConfigParser
import glob
import iscpy
from fabric import api as fabric_api
from fabric import state as fabric_state

from optparse import OptionParser

from roster_config_manager import config_lib

COMMANDS_CONVERT_DICT = {
    'check-dup-records': {'fail': 'fail', 'warn': 'warn', 'ignore': 'ignore'},
    'check-mx':          {'fail': 'fail', 'warn': 'warn', 'ignore': 'ignore'},
    'check-mx-cname':   {'fail': 'fail', 'warn': 'warn', 'ignore': 'ignore'},
    'check-srv-cname':   {'fail': 'fail', 'warn': 'warn', 'ignore': 'ignore'},
    'check-wildcard':    {'yes': 'warn', 'no': 'ignore'},

    'check-names':       {'flag': '-k', 'default': 'fail'},
    'check-integrity':   {'yes': 'full', 'no': 'none'},
}

CHECKZONE_ARGS_DICT = {
    'check-dup-records': {'flag': '-r', 'arg': 'warn'},
    'check-mx':          {'flag': '-m', 'arg': 'warn'},
    'check-mx-cname':    {'flag': '-M', 'arg': 'warn'},
    'check-srv-cname':   {'flag': '-S', 'arg': 'warn'},

    'check-wildcard':    {'flag': '-W', 'arg': 'warn'},
    'check-names':       {'flag': '-k', 'arg': 'fail'},
    'check-integrity':   {'flag': '-i', 'arg': 'full'},
}

#Option clauses that we're interested in, and their default BIND value.
BIND_OPTION_CLAUSES = {
    'check-dup-records': 'warn',
    'check-mx':          'warn',
    'check-mx-cname':    'warn',
    'check-srv-cname':   'warn',
    'check-wildcard':    'yes',
    'check-names':       'warn',
    'check-integrity':   'yes',
    'check-siblings':    'yes'
}

def ChangeNamedDirectory(file_name, directory):
  """Changed the directory for named in options.

  Inputs:
    file_name: string of the filename
    directory: string of the directory
  """
  file_handle = open(file_name, 'r')
  try:
    file_contents = file_handle.readlines()
    file_handle.close()

    for line_index, line in enumerate(file_contents):
      if( ' directory "' in line ):
        line_contents = line.split(' directory "')
        new_line = '%s directory "%s"%s' % (line_contents[0],
                                            directory,
                                            line_contents[1].split('"', 1)[1])
        file_contents[line_index] = new_line
        file_handle = open(file_name, 'w')
        file_handle.writelines(file_contents)
        break
      # Also check for newline in front of directory and do same
      elif( '\ndirectory "' in line ):
        line_contents = line.split('\ndirectory "')
        new_line = '%s directory "%s"%s' % (line_contents[0],
                                            directory,
                                            line_contents[1].split('"', 1)[1])
        file_contents[line_index] = new_line
        file_handle = open(file_name, 'w')
        file_handle.writelines(file_contents)
        break

    else:
      print "Couldn't find directory in named conf file"
      sys.exit(1)

  finally:
    file_handle.close()

def MergeOptionsDicts(global_options_dict, view_dict, zone_dict):
  """Merges the options of 3 dictionaries, according to precendence.
  zone_dict is the most importantce, while global_options_dict has the "least"
  importantance.
  
    Inputs:
      global_options_dict: dict of the options defined globally in named.conf
      view_dict: dict of the options defined in a single view of named.conf
      zone_dict: dict of the options defined in a single zone of named.conf

    Outputs:
      single_options_dict: dict of the merged options
  """

  single_options_dict = {}

  #Go in order of least important to most important
  for options_dict in [global_options_dict, view_dict, zone_dict]:
    for key in options_dict.keys():
      if( key in BIND_OPTION_CLAUSES ):
        single_options_dict[key] = options_dict[key]

  #If we didn't fill in any of the options, we want to fill in their defaults
  for key in BIND_OPTION_CLAUSES:
    if( key not in single_options_dict.keys() ):
      single_options_dict[key] = BIND_OPTION_CLAUSES[key]

  return single_options_dict

def GenerateAdditionalNamedCheckzoneArgs(bind_options_dict):
  """Generates additional named-checkzone command line flags and arguments based
  on the BIND options supplied in bind_options_dict.
  
  Inputs:
    bind_options_dict: dict of BIND options parsed from named.conf
    
  Outputs:
    args: list of flags and their args.
  """
   
  args = []
  check_siblings = False

  for option_key, option_value in bind_options_dict.items():
    if( option_key != 'check-siblings' ):
      checkzone_arg = None
      if( option_value in COMMANDS_CONVERT_DICT[option_key] ):
        checkzone_arg = COMMANDS_CONVERT_DICT[option_key][option_value]
      else:
        #These checks are for global and view options
        #In some clauses, fail, warn, and ignore are not enough.
        #master/slave/response warn/fail/ignore is the correct syntax.
        if( 'fail' in option_value ):
          checkzone_arg = 'fail'
        elif( 'warn' in option_value ):
          checkzone_arg = 'warn'
        elif( 'ignore' in option_value ):
          checkzone_arg = 'ignore'
        else:
          print 'ERROR: Unknown option "%s %s"' % (option_key, option_value)
          sys.exit(1)

      CHECKZONE_ARGS_DICT[option_key]['arg'] = checkzone_arg
    else:
      if( option_value == 'yes' ):
        check_siblings = True

  #if we want to check siblings, and if we are checking integrity,
  #append '-sibling' to the -i arg of the CHECKZONE_ARGS_DICT
  if( check_siblings and 
      CHECKZONE_ARGS_DICT['check-integrity']['arg'] != 'none' ):
    CHECKZONE_ARGS_DICT['check-integrity']['arg'] = '%s-sibling' % (
      CHECKZONE_ARGS_DICT['check-integrity']['arg'])

  #Transferring everything from CHECKZONE_ARGS_DICT to args list
  for key in CHECKZONE_ARGS_DICT:
    flag = CHECKZONE_ARGS_DICT[key]['flag']
    arg = CHECKZONE_ARGS_DICT[key]['arg']

    args.extend([flag, arg])

  return args

def main(args):
  """Collects command line arguments. Checks configs.

  Inputs:
    args: list of arguments from the command line
  """
  usage = ('\n'
           '\n'
           'To check config files in an audit id:\n'
           '\t%s -i <audit-id> [--config-file <config-file>]\n'
           '\t[-z <checkzone-binary>] [-c <checkconf-binary>] [-v]\n' % sys.argv[0])

  parser = OptionParser(version='%%prog (Roster %s)' % __version__, usage=usage)

  parser.add_option('-s', '--server', action='store', dest='server',
                    help='Server to check config file for.', metavar='<server>',
                    default=None)
  parser.add_option('-d', '--directory', action='store', dest='directory',
                    help='Directory to scan.', metavar='<directory>',
                    default=None)
  parser.add_option('-o', '--output-directory', action='store',
                    dest='output_directory',
                    help='Directory to temporarily output files to. Must be '
                         'same in named.conf.', default='temp_dir')
  parser.add_option('-z', '--named-checkzone', action='store',
                    dest='named_checkzone',
                    help='Location of named_checkzone binary.',
                    default='/usr/sbin/named-checkzone')
  parser.add_option('-c', '--named-checkconf', action='store',
                    dest='named_checkconf',
                    help='Location of named_checkconf binary.',
                    default='/usr/sbin/named-checkconf')
  parser.add_option('-v', '--verbose', dest='verbose', action='store_true',
                    help='Make command verbose.', default=False)
  parser.add_option('--config-file', action='store', dest='config_file',
                    help='Config File Location', metavar='<config-file>',
                    default='/etc/roster/roster_server.conf')
  parser.add_option('--info-file', action='store', dest='info_file',
                    help='Server Info File Location', metavar='<info-file>')
  parser.add_option('-i', '--id', dest='id',
                    help='ID of tarfile output from Roster tree export.',
                    metavar='<id>', default=None)
  parser.add_option('--just-local', action='store_true', dest='just_local',
                    help='Only check config locally.', default=False)

  (globals()['options'], args) = parser.parse_args(args)

  if( os.path.exists(options.output_directory) ):
    shutil.rmtree(options.output_directory)

  server_config_file = ConfigParser.SafeConfigParser()
  server_config_file.read(options.config_file)

  if( not options.just_local and not options.server ):
    print 'ERROR: Server flag "-s/--server" cannot be empty.'
    sys.exit(1)

  config_lib_instance = config_lib.ConfigLib(options.config_file)
  config_lib_instance.UnTarDnsTree(audit_log_id=options.id)

  try:
    backup_directory = options.directory
    if( not options.directory ):
      backup_directory = server_config_file.get('exporter',
                                                'backup_dir').rstrip('/')

    temp_root_directory = server_config_file.get('exporter',
                                                 'root_config_dir').rstrip('/')
    if( not os.path.exists(temp_root_directory) ):
      os.makedirs(temp_root_directory)

    err_files = []
    try:
      file_list = os.listdir(backup_directory)
    except OSError:
      print ('ERROR: Directory %s does not exist or you '
             'do not have permission.' % backup_directory)
      sys.exit(1)
    if( options.id ):
      for file_name in file_list:
        if( not file_name.startswith('dns_tree') ):
          continue
        try:
          if( file_name.split('-')[1].split('.')[0] == options.id ):
            tar = tarfile.open('%s/%s' % (backup_directory, file_name))
            try:
              tar.extractall()
            finally:
              tar.close()
            shutil.move(temp_root_directory, options.output_directory)
            break
        except IndexError:
          err_files.append(file_name)
          continue
          # If this error occurs, skip if correct numbered file is found.
      else:
        # No break, could mean wrong filenames or nonexistant
        if( err_files ):
          print 'ERROR: Filenames: %s not named correctly' % ', '.join(err_files)
        else:
          print 'ERROR: ID %s not found.' % options.id
        sys.exit(1)
    else:
      newest = -1
      new_file_name = None
      for file_name in file_list:
        if( not file_name.startswith('dns_tree') ):
          continue
        try:
          id = int(file_name.split('-')[1].split('.')[0])
        except IndexError:
          err_files.append(file_name)
          break
          # If this error occurs, error out completely
        if( id > newest ):
          newest = id
          new_file_name = file_name
      file_name = new_file_name
      if( err_files ):
        print 'ERROR: Filenames: %s not named correctly' % ', '.join(err_files)
        sys.exit(1)
      if( new_file_name is None ):
        print ('ERROR: An unknown error has occurred trying to find the newest '
               'file.')
        sys.exit(1)
      tar = tarfile.open('%s/%s' % (backup_directory, file_name))
      try:
        tar.extractall(temp_root_directory)
      finally:
        tar.close()
      shutil.move(temp_root_directory, options.output_directory)

    if( not os.path.exists(options.named_checkzone) ):
      print 'ERROR: Could not find "named-checkzone" binary.'
      sys.exit(1)
    if( not os.path.exists(options.named_checkconf) ):
      print 'ERROR: Could not find "named-checkconf" binary.'
      sys.exit(1)

    fabric_state.output['running'] = False
    fabric_state.output['warnings'] = False
    fabric_api.env.warn_only = True
    named_files = glob.glob('%s/*/named.conf.a' % options.output_directory)
    for current_file in named_files:
      ChangeNamedDirectory(current_file, options.output_directory)
      checknamed_text = fabric_api.local('%s %s' % (
          options.named_checkconf, current_file), capture=True)
      if( checknamed_text == '' ):
        if( options.verbose ):
          print 'Finished - %s' % current_file
      else:
        print 'ERROR: %s' % checknamed_text
        sys.exit(1)

    #Turns ['temp_dir/localhost/named.conf.a'] into ['temp_dir/localhost']
    named_dirs = [os.path.dirname(fname) for fname in named_files]

    #Check zones, one named_dir at a time
    for named_dir in named_dirs:

      #The named file for the zones we're about to check
      named_file_name = os.path.join(named_dir, 'named.conf.a')

      try:
        named_file_handle = open(named_file_name, 'r')
        named_file_string = named_file_handle.read()
      finally:
        named_file_handle.close()

      named_file_dict = iscpy.ParseISCString(named_file_string)
      global_options_dict = named_file_dict['options']
      zone_files = glob.glob('%s/*/*/*.db' % named_dir)

      for current_file in zone_files:
        #The view name that this current_file belongs to
        view_name = os.path.dirname(current_file).split('/').pop()

        #The zones that the view name determined above, governs
        view_dict = named_file_dict['view "%s"' % view_name]

        #Finding the zone dictionary in view_dict, that is the zone_dictionary
        #for the zone represented by current_file
        zone_dict = None
        for zone in view_dict:
          #Making sure we're checking a dictionary
          if( type(view_dict[zone]) == type({}) ):
            if( 'file' in view_dict[zone].keys() ):
              if( view_dict[zone]['file'].strip('"') in current_file ):
                zone_dict = view_dict[zone]
                break
        else:
          print('Zone file %s is in the named directory %s, '
               'but not in it\'s named.conf' % (current_file, named_dir))
          sys.exit(1)

        options_dict = MergeOptionsDicts(
            global_options_dict, view_dict, zone_dict)
        additional_args = GenerateAdditionalNamedCheckzoneArgs(options_dict)

        file_handle = open(current_file, 'r')
        try:
          file_contents = file_handle.read().split('\n')
        finally:
          file_handle.close()
        for line in file_contents:
          if( line.startswith('$ORIGIN') and len(line.split()) == 2 ):
            origin = line.split()[1]
            break
        else:
          print 'ERROR: Could not find $ORIGIN in "%s"' % current_file
          sys.exit(1)

        additional_args_string = ' '.join(additional_args)
        checkzone_command = ('%s %s %s %s' % (
            options.named_checkzone, additional_args_string, 
            origin, current_file))

        checkzone_text = fabric_api.local(checkzone_command, capture=True)

        if( checkzone_text.endswith('\nOK') ):
          if( options.verbose ):
            print 'Finished - %s' % current_file
        else:
          print 'ERROR: %s' % checkzone_text
          sys.exit(1)

    if( options.verbose ):
      print '--------------------------------------------------------------------'
      print 'Checked %s named.conf file(s) and %s zone file(s)\n' % (
          len(named_files), len(zone_files))
      print 'All checks successful'
  finally:
    if( os.path.exists(config_lib_instance.root_config_dir) ):
      shutil.rmtree(config_lib_instance.root_config_dir)

if __name__ == '__main__':
    main(sys.argv[1:])
