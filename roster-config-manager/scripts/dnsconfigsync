#!/usr/bin/env python

# Copyright (c) 2009, Purdue University
# All rights reserved.
# 
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
# 
# Redistributions of source code must retain the above copyright notice, this
# list of conditions and the following disclaimer.
#
# Redistributions in binary form must reproduce the above copyright notice, this
# list of conditions and the following disclaimer in the documentation and/or
# other materials provided with the distribution.
# 
# Neither the name of the Purdue University nor the names of its contributors
# may be used to endorse or promote products derived from this software without
# specific prior written permission.
# 
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
# DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
# FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
# DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
# SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
# CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
# OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
# OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

"""Tree sync tool for Roster"""


__copyright__ = 'Copyright (C) 2009, Purdue University'
__license__ = 'BSD'
__version__ = '#TRUNK#'


import sys
import shutil
import os
import ssh
import tarfile
import iscpy
import re
from fabric import api as fabric_api
from fabric import exceptions as fabric_exceptions
from fabric import state as fabric_state
from fabric import network as fabric_network
from roster_config_manager import config_lib

from optparse import OptionParser
import ConfigParser

from roster_core import constants

#BIND default
DEFAULT_RNDC_PORT = 953

def PushFiles(dns_server, config_lib_instance, rndc_exec='rndc', 
    ssh_id_file=None, dns_server_rndc_port=None):
  """Pushes files to a remote directory over SSH, and refreshes rndc.
  Inputs:
    dns_server: name of the dns_server to push files to.
    config_lib_instance: ConfigLib object
    rndc_exec: string of path to rndc executable
    ssh_id_file: string of path to SSH private key file
    dns_server_rndc_port: int of port to connect rndc to
  Raises:
    ExporterNoFileError: Could not fnid a DNS tree in the root_config_dir
    ServerCheckError:
      DNS server does not exist
      A server check has not been run on a DNS server
      Failed to move compressed BIND tree to DNS server
      Failed to untar compressed BIND tree on DNS server
      A named.conf check failed on the DNS server
      A zone did not pass named-checkzone
      Failed to compile zone
      Lost SSH connection to DNS server
      Unable to connect via SSH to DNS server
      Failed to reload DNS server via rndc reload
  """
  root_config_dir = config_lib_instance.root_config_dir
  if( not os.path.exists(root_config_dir) or
      len(os.listdir(root_config_dir)) < 1 ):
    raise config_lib.ExporterNoFileError('Could not find a DNS tree in %s.' % 
                                         root_config_dir)
  
  dns_server_directory = '%s/%s' % (root_config_dir, dns_server)
  if( not os.path.exists(dns_server_directory) ):
    raise config_lib.ServerCheckError('DNS server %s does not exist. %s' % 
                                      dns_server)
  
  dns_server_info = config_lib_instance.GetDnsServerInfo(dns_server)
  if( not dns_server_rndc_port ):
    rndc_port_found = False
    named_conf_string = open(
        os.path.join(root_config_dir, dns_server, 'named.conf.a'), 'r').read()
    named_conf_dict = iscpy.ParseISCString(named_conf_string)
    if( 'controls' in named_conf_dict ):
      named_conf_dict = named_conf_dict['controls']
      for sub_dict in named_conf_dict:
        for key in sub_dict:
          if( 'inet' in key and 'port' in key ):
            #Turns 'inet 192.168.what.ever port 1234 allow' into 
            #['inet 192.168.what.ever ', ' 1234 allow']
            port_split_list = key.split('port')

            if len(port_split_list) > 1:
              #Results in '1234 allow'
              port_segment = port_split_list[1].strip(' ')

              #Results in ' allow'
              to_strip = ''.join(re.split('\A[0-9]{1,5}', port_segment))

              #Results in '1234'
              port_string = port_segment.strip(to_strip) 

              if port_string.isdigit():
                dns_server_rndc_port = int(port_string)
                rndc_port_found = True

    if( not rndc_port_found ):
      print 'rndc port not found in named.conf. Using default of %s' % (
          DEFAULT_RNDC_PORT)
      dns_server_rndc_port = DEFAULT_RNDC_PORT

  dns_server_info['server_info']['bind_dir'] = dns_server_info['server_info'][
      'bind_dir'].rstrip('/')
  dns_server_info['server_info']['test_dir'] = dns_server_info['server_info'][
      'test_dir'].rstrip('/')
  if( dns_server_info['server_info']['bind_version'].lower() == 
      'undetermined' ):
    raise config_lib.ServerCheckError('A server check has not been run on %s.' %
                           dns_server)
  ssh_host = '%s@%s:22' % (dns_server_info['server_info']['server_user'],
                           dns_server_info['server_info']['server_name'])
  
  checkzone = ('named-checkzone' in dns_server_info['tools'] and 
               dns_server_info['tools']['named-checkzone'])
  checkconf = ('named-checkconf' in dns_server_info['tools'] and 
               dns_server_info['tools']['named-checkconf'])
  compilezone = ('named-compilezone' in dns_server_info['tools'] and 
                 dns_server_info['tools']['named-compilezone'])
  tar = ('tar' in dns_server_info['tools'] and dns_server_info['tools']['tar'])
  try:
    if( ssh_id_file is not None ):
      fabric_api.env.key_filename = ssh_id_file
    fabric_api.env.warn_only = True
    for out in fabric_state.output:
      fabric_state.output[out] = False
    fabric_api.env.host_string = ssh_host
    fabric_api.run('rm -rf %s/*' % dns_server_info['server_info']['test_dir'])

    # Prepare and push BIND tree to server
    if( tar ):
      config_lib_instance.TarDnsBindFiles(dns_server)
      result = fabric_api.put('%s/%s.tar.bz2' % 
          (dns_server_directory, dns_server),
          '%s/%s.tar.bz2' % (dns_server_info['server_info']['test_dir'], 
          dns_server))
      if( not result.succeeded ):
        raise config_lib.ServerCheckError('Failed to move compressed BIND tree '
                                          'to server %s.' % dns_server)
      with fabric_api.cd(dns_server_info['server_info']['test_dir']):
        result = fabric_api.run('tar -xf %s/%s.tar.bz2' % (dns_server_info[
            'server_info']['test_dir'], dns_server))
      os.remove('%s/%s/%s.tar.bz2' % (root_config_dir, dns_server, dns_server))
      if( result.return_code != 0 ):
        raise config_lib.ServerCheckError('Failed to untar compressed BIND '
            'tree on server %s.' % dns_server)
      result = fabric_api.run('ls %s' % 
          dns_server_info['server_info']['test_dir'])
      if( 'named.conf.a' not in result ):
        raise config_lib.ServerCheckError('Failed to untar compressed BIND '
            'tree on server %s.' % dns_server)
      fabric_api.run('rm %s/%s.tar.bz2' % (dns_server_info['server_info'][
          'test_dir'], dns_server))
    else:
      result = fabric_api.put('%s/*' % dns_server_directory, 
          dns_server_info['server_info']['test_dir'])
      if( not result.succeeded ):
        raise config_lib.ServerCheckError('Failed in moving BIND tree files '
            'to server %s.' % dns_server)
    fabric_api.run('rm %s/%s.info' % (dns_server_info['server_info'][
        'test_dir'], dns_server))

    # Check and prepare named.conf file
    result = fabric_api.run('ls %s/named' % dns_server_info[
        'server_info']['bind_dir'])
    if( result.return_code!=0 ):
      fabric_api.run('mkdir %s/named' % dns_server_info['server_info'][
          'bind_dir'])

    conf_keep = ''
    conf_remove = ''
    if( checkconf and compilezone ):
      result = fabric_api.run('named-checkconf %s/named.conf.b' % 
          dns_server_info['server_info']['test_dir'])
      if( result.return_code != 0 ):
        raise config_lib.ServerCheckError('Binary named.conf check failed '
            'on %s.' % dns_server)
    elif( checkconf ):
      result = fabric_api.run('named-checkconf %s/named.conf.a' % 
          dns_server_info['server_info']['test_dir'])
      if( result.return_code != 0 ):
        raise config_lib.ServerCheckError('Named.conf check failed on %s.' % 
            dns_server)
    
    if( compilezone ):
      conf_keep = '%s/named.conf.b' % dns_server_info['server_info']['test_dir']
      conf_remove = '%s/named.conf.a' % dns_server_info['server_info'][
          'test_dir']
    else:
      conf_keep = '%s/named.conf.a' % dns_server_info['server_info']['test_dir']
      conf_remove = '%s/named.conf.b' % dns_server_info['server_info'][
          'test_dir']
    fabric_api.run('rm %s' % conf_remove)
    fabric_api.run('mv %s %s/named.conf' % (conf_keep, 
        dns_server_info['server_info']['test_dir']))

    # Check and compile zone files
    if( checkzone or compilezone ):
      zone_dict = config_lib_instance.GetZoneList(dns_server)
      for view in zone_dict:
        view_dir = '%s/named/%s' % (
            dns_server_info['server_info']['test_dir'], view)
        for zone_origin in zone_dict[view]:
          zone_file_name = '%s/%s' % (view_dir, zone_dict[view][zone_origin])
          zone_tool_arguments = config_lib_instance.GetNamedZoneToolArgs(\
              dns_server, view, zone_dict[view][zone_origin])
          if( checkzone ):
            result = fabric_api.run('named-checkzone %s %s %s' % (
                zone_tool_arguments, zone_origin, zone_file_name))
            if( result.return_code != 0 ):
              raise config_lib.ServerCheckError('Zone %s did not pass the '
                                                'check.' % zone_origin)

          if( compilezone ):
            zone_binary_file_name = '%s.aa' % zone_file_name.rstrip('.db')
            result = fabric_api.run('named-compilezone -F raw %s -o %s %s %s' % (
                zone_tool_arguments, zone_binary_file_name, zone_origin,
                zone_file_name))
            fabric_api.run('rm %s' % zone_file_name)
            if( result.return_code != 0 ):
              raise config_lib.ServerCheckError('Failed to compile zone %s.' % 
                                     zone_origin)
            
            if( checkzone ):
              result = fabric_api.run('named-checkzone -f raw %s %s %s' % (
                  zone_tool_arguments, zone_origin, zone_binary_file_name))
              if( result.return_code != 0 ):
                raise config_lib.ServerCheckError('Zone check on binary zone '
                    '%s failed.' % zone_origin)

    # Move files in BIND tree to BIND directory
    result = fabric_api.run('cp %s/named.conf %s/named.conf' % (
        dns_server_info['server_info']['test_dir'], 
        dns_server_info['server_info']['bind_dir']))
    if( result.return_code != 0 ):
      raise config_lib.ServerCheckError('Failed to move files from '
          'test directory to bind directory on server %s.' % dns_server)
    try:
      result = fabric_api.run('cp -rf %s/named/* %s/named/ &' % (
          dns_server_info['server_info']['test_dir'], 
          dns_server_info['server_info']['bind_dir']), pty=False)
    except ssh.SSHException:
      raise config_lib.ServerCheckError('Lost SSH connection to %s while '
          'moving files from test directory to BIND directory.' % dns_server)
    fabric_api.run('rm -rf %s/* &' % 
                   dns_server_info['server_info']['test_dir'], pty=False)

    rndc_exec = '%s -p %s' % (
        rndc_exec, dns_server_rndc_port)

    # Reload BIND server
    result = fabric_api.run('%s reload' % rndc_exec)
    if( result.return_code != 0 ):
        raise config_lib.ServerCheckError('Failed to reload %s BIND '
            'server: %s.' % (dns_server, result))
  except fabric_exceptions.NetworkError:
    raise config_lib.ServerCheckError('Could not connect to %s via SSH.' % 
                                      dns_server)
  except ssh.SSHException:
    raise config_lib.ServerCheckError('Lost connection to %s.' % dns_server)
  finally:
    fabric_network.disconnect_all()

def main(args):
  """Collects command line arguments. Exports tree.

  Inputs:
    args: list of arguments from the command line
  """
  usage = ('\n'
           '\n'
           'To sync bind trees:\n'
           '\t%s -i <audit-id> [-c <config-file>] '
           '[-d <dest-directory>]\n' % sys.argv[0])

  parser = OptionParser(version='%%prog (Roster %s)' % __version__, usage=usage)
  
  parser.add_option('--export-config', action='store_true', dest='export_config',
                    help='This flag is used when dnsconfigsync is called from '
                    'dnsexportconfig. This should not be used by any user.',
                    metavar='<export_config>', default=False)
  parser.add_option('-d', '--dns-server', action='store', dest='dns_server',
                    help='DNS Server Name', metavar='<dns-server>',
                    default=None)
  parser.add_option('-c', '--config-file', action='store', dest='config_file',
                    help='Config File Location', metavar='<config-file>',
                    default=constants.SERVER_CONFIG_FILE_LOCATION)
  parser.add_option('-i', '--id', dest='id',
                    help='ID of tarfile output from Roster tree export.',
                    metavar='<id>', default=None)
  parser.add_option('--ssh-id', action='store', dest='ssh_id',
                    help='SSH id file.', metavar='<ssh-id>',
                    default=None)
  parser.add_option('--rndc-exec', action='store', dest='rndc_exec',
                    help='RNDC executable location.', metavar='<rndc-exec>',
                    default='rndc')
  parser.add_option('--rndc-key', action='store', dest='rndc_key',
                    help='RNDC key file.', metavar='<rndc-key>',
                    default=None)
  parser.add_option('--rndc-conf', action='store', dest='rndc_conf',
                    help='RNDC conf file.', metavar='<rndc-conf>',
                    default=None)
  parser.add_option('--rndc-port', action='store', dest='rndc_port',
                    help='RNDC communication port. If none provided, '
                    'named.conf will be parsed to find one. If one can not '
                    'be found, 953 will be used.', metavar='<rndc-port>',
                    default=None)

  (globals()["options"], args) = parser.parse_args(args)

  if( options.dns_server is None ):
    print('ERROR: DNS server not given.')
    sys.exit(1)
  
  config_lib_instance = config_lib.ConfigLib(options.config_file)
  server_config_file = ConfigParser.SafeConfigParser()
  server_config_file.read(options.config_file)

  root_config_dir = os.path.abspath(os.path.expanduser(
      server_config_file.get('exporter', 'root_config_dir').rstrip('/')))

  if( not options.export_config ):
    if( os.path.exists(root_config_dir) ):
      shutil.rmtree(root_config_dir)
    config_lib_instance.UnTarDnsTree(options.id)

  if( options.rndc_key ):
    if( options.rndc_key.startswith('./')
        or not options.rndc_key.startswith('/') ):
      options.rndc_key = '%s/%s' % (os.getcwd(), options.rndc_key.lstrip('./'))
    options.rndc_exec = '%s -k %s' % (
        options.rndc_exec, os.path.expanduser(options.rndc_key))
  if( options.rndc_conf ):
    if( options.rndc_conf.startswith('./')
        or not options.rndc_conf.startswith('/') ):
      options.rndc_conf = '%s/%s' % (os.getcwd(),options.rndc_conf.lstrip('./'))
    options.rndc_exec = '%s -c %s' % (
        options.rndc_exec, os.path.expanduser(options.rndc_conf))

  try:
    PushFiles(options.dns_server, config_lib_instance, 
        rndc_exec=options.rndc_exec, ssh_id_file=options.ssh_id,
        dns_server_rndc_port=options.rndc_port) 
  except config_lib.ConfigManagerError as err:
    print('ERROR: %s' % err.message)
    sys.exit(1)

  if( not options.export_config ):
    shutil.rmtree(root_config_dir)

if __name__ == "__main__":
    main(sys.argv[1:])
